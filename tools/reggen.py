#!/usr/bin/env python3
import sys, os, json, subprocess
try:
    import yaml
except Exception:
    print("This tool requires PyYAML (pip install pyyaml)")
    sys.exit(2)

GEN_VERSION = "reggen.py 0.1.0"

def _git_rev_short(path: str) -> str:
    try:
        # YAML-specific last commit, falling back to repo head
        out = subprocess.check_output(["git", "log", "-n", "1", "--format=%h", "--", path], stderr=subprocess.DEVNULL)
        h = out.decode().strip()
        if h:
            return h
    except Exception:
        pass
    try:
        out = subprocess.check_output(["git", "rev-parse", "--short", "HEAD"], stderr=subprocess.DEVNULL)
        return out.decode().strip()
    except Exception:
        return "unknown"

HEADER_EPILOGUE = """
#ifdef __cplusplus
}
#endif
"""

def gen_header(device_yaml: str, out_dir: str):
    with open(device_yaml, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    device = data['device']
    blocks = data.get('blocks', [])
    pcie_caps = data.get('pcie_caps', [])
    name = device.upper()

    yaml_rev = _git_rev_short(device_yaml)
    repo_rev = _git_rev_short(os.path.dirname(device_yaml) or ".")

    header_prologue = f"""
/* SPDX-License-Identifier: MIT */
/* Auto-generated by intel-ethernet-regs/tools/reggen.py ({GEN_VERSION}) */
/* Source YAML: {os.path.basename(device_yaml)} @ {yaml_rev}; Repo: {repo_rev} */
#pragma once
#ifdef __cplusplus
extern "C" {{
#endif
"""

    lines = [header_prologue]
    guard = f"INTEL_{name}_REGS_H"
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")

    def parse_hex_or_int(v):
        if isinstance(v, int):
            return v
        if isinstance(v, str):
            v = v.strip()
            if v.lower().startswith('0x'):
                return int(v, 16)
            return int(v)
        raise TypeError(f"Unsupported numeric type: {type(v)}")

    # Emit PCIe capability constants (cap IDs and relative offsets)
    if pcie_caps:
        lines.append(f"/* PCI/PCIe Capabilities for {name} (PCI config space) */")
        # Generic helper macros for capability scanning (header-defined only)
        lines.append(f"#define {name}_PCIE_CAP_ID(vid)\t(vid)")
        for cap in pcie_caps:
            cap_name = str(cap.get('name', 'CAP')).upper()
            cap_id = cap.get('cap_id')
            cap_id_val = None
            if isinstance(cap_id, int):
                cap_id_val = cap_id
            elif isinstance(cap_id, str):
                cap_id_val = int(cap_id, 16) if cap_id.lower().startswith('0x') else int(cap_id)
            else:
                cap_id_val = 0
            lines.append(f"#define {name}_{cap_name}_CAP_ID\t0x{cap_id_val:04X}")
            # Registers within the capability
            for reg in cap.get('registers', []):
                rname = f"{cap_name}_{str(reg.get('name','REG')).upper()}"
                roff = reg.get('offset', '0x0')
                if isinstance(roff, int):
                    off_val = roff
                else:
                    off_val = int(roff, 16) if roff.lower().startswith('0x') else int(roff)
                lines.append(f"#define {name}_{rname}\t0x{off_val:02X}")
                fields = reg.get('fields', [])
                for fld in fields:
                    fname = f"{rname}_{fld['name'].upper()}"
                    lsb = int(fld['lsb'])
                    fwidth = int(fld['width'])
                    mask_expr = f"((1U<<{fwidth})-1U)" if fwidth < 32 else "0xFFFFFFFFU"
                    lines.append(f"#define {name}_{fname}_SHIFT\t{lsb}")
                    lines.append(f"#define {name}_{fname}_MASK\t({mask_expr} << {name}_{fname}_SHIFT)")
            lines.append("")
        lines.append("")

    for blk in blocks:
        base = parse_hex_or_int(blk['base'])
        blk_name = blk['name'].upper()
        lines.append(f"/* Block {blk_name} base: 0x{base:05X} */")
        for reg in blk.get('registers', []):
            roff = parse_hex_or_int(reg['offset'])
            rname = reg['name'].upper()
            abs_off = base + roff
            desc = reg.get('description', '')
            access = reg.get('access')
            reset = reg.get('reset')
            if desc:
                lines.append(f"/* {desc} */")
            if access or reset:
                meta = []
                if access:
                    meta.append(f"access={access}")
                if reset:
                    meta.append(f"reset={reset}")
                lines.append(f"/* {'; '.join(meta)} */")
            count = int(reg.get('count', 0) or 0)
            stride = reg.get('stride')
            if count and stride is not None:
                stride_val = parse_hex_or_int(stride)
                for i in range(count):
                    off_i = abs_off + i * stride_val
                    lines.append(f"#define {name}_{rname}{i}\t0x{off_i:05X}")
            else:
                lines.append(f"#define {name}_{rname}\t0x{abs_off:05X}")

            # Emit field macros if present
            fields = reg.get('fields', [])
            for fld in fields:
                fname = f"{rname}_{fld['name'].upper()}"
                lsb = int(fld['lsb'])
                fwidth = int(fld['width'])
                if fwidth >= 64:
                    mask_expr = "(~0ULL)"
                else:
                    mask_expr = f"((1ULL<<{fwidth})-1ULL)"
                lines.append(f"#define {name}_{fname}_SHIFT\t{lsb}")
                lines.append(f"#define {name}_{fname}_MASK\t({mask_expr} << {name}_{fname}_SHIFT)")
                # Enums if any
                enums = fld.get('enums', {})
                for ev, ename in enums.items():
                    try:
                        ev_int = int(ev)
                    except Exception:
                        continue
                    lines.append(f"#define {name}_{fname}_{str(ename).upper()}\t{ev_int}U")
            if fields:
                # Inline helpers once per register
                lines.append(f"static inline unsigned long long {name}_{rname}_GET(unsigned long long v, unsigned long long mask, unsigned shift) {{ return (v & mask) >> shift; }}")
                lines.append(f"static inline unsigned long long {name}_{rname}_SET(unsigned long long v, unsigned long long mask, unsigned shift, unsigned long long val) {{ return (v & ~mask) | ((val << shift) & mask); }}")
        lines.append("")

    lines.append(f"#endif /* {guard} */")
    lines.append(HEADER_EPILOGUE)

    os.makedirs(out_dir, exist_ok=True)
    out_path = os.path.join(out_dir, f"{device.lower()}_regs.h")
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))
    return out_path

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: reggen.py <device.yaml> <out_dir>")
        sys.exit(1)
    out = gen_header(sys.argv[1], sys.argv[2])
    print(out)
