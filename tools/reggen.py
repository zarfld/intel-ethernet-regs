#!/usr/bin/env python3
import sys, os, json
try:
    import yaml
except Exception:
    print("This tool requires PyYAML (pip install pyyaml)")
    sys.exit(2)

HEADER_PROLOGUE = """
/* Auto-generated by intel-ethernet-regs/tools/reggen.py */
#pragma once
#ifdef __cplusplus
extern "C" {
#endif
"""

HEADER_EPILOGUE = """
#ifdef __cplusplus
}
#endif
"""

def gen_header(device_yaml: str, out_dir: str):
    with open(device_yaml, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    device = data['device']
    blocks = data.get('blocks', [])
    name = device.upper()

    lines = [HEADER_PROLOGUE]
    guard = f"INTEL_{name}_REGS_H"
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")

    def parse_hex_or_int(v):
        if isinstance(v, int):
            return v
        if isinstance(v, str):
            v = v.strip()
            if v.lower().startswith('0x'):
                return int(v, 16)
            return int(v)
        raise TypeError(f"Unsupported numeric type: {type(v)}")

    for blk in blocks:
        base = parse_hex_or_int(blk['base'])
        blk_name = blk['name'].upper()
        lines.append(f"/* Block {blk_name} base: 0x{base:05X} */")
        for reg in blk.get('registers', []):
            roff = parse_hex_or_int(reg['offset'])
            rname = reg['name'].upper()
            abs_off = base + roff
            desc = reg.get('description', '')
            access = reg.get('access')
            reset = reg.get('reset')
            if desc:
                lines.append(f"/* {desc} */")
            if access or reset:
                meta = []
                if access:
                    meta.append(f"access={access}")
                if reset:
                    meta.append(f"reset={reset}")
                lines.append(f"/* {'; '.join(meta)} */")
            count = int(reg.get('count', 0) or 0)
            stride = reg.get('stride')
            if count and stride is not None:
                stride_val = parse_hex_or_int(stride)
                for i in range(count):
                    off_i = abs_off + i * stride_val
                    lines.append(f"#define {name}_{rname}{i}\t0x{off_i:05X}")
            else:
                lines.append(f"#define {name}_{rname}\t0x{abs_off:05X}")

            # Emit field macros if present
            fields = reg.get('fields', [])
            for fld in fields:
                fname = f"{rname}_{fld['name'].upper()}"
                lsb = int(fld['lsb'])
                fwidth = int(fld['width'])
                if fwidth >= 64:
                    mask_expr = "(~0ULL)"
                else:
                    mask_expr = f"((1ULL<<{fwidth})-1ULL)"
                lines.append(f"#define {name}_{fname}_SHIFT\t{lsb}")
                lines.append(f"#define {name}_{fname}_MASK\t({mask_expr} << {name}_{fname}_SHIFT)")
                # Enums if any
                enums = fld.get('enums', {})
                for ev, ename in enums.items():
                    try:
                        ev_int = int(ev)
                    except Exception:
                        continue
                    lines.append(f"#define {name}_{fname}_{str(ename).upper()}\t{ev_int}U")
            if fields:
                # Inline helpers once per register
                lines.append(f"static inline unsigned long long {name}_{rname}_GET(unsigned long long v, unsigned long long mask, unsigned shift) {{ return (v & mask) >> shift; }}")
                lines.append(f"static inline unsigned long long {name}_{rname}_SET(unsigned long long v, unsigned long long mask, unsigned shift, unsigned long long val) {{ return (v & ~mask) | ((val << shift) & mask); }}")
        lines.append("")

    lines.append(f"#endif /* {guard} */")
    lines.append(HEADER_EPILOGUE)

    os.makedirs(out_dir, exist_ok=True)
    out_path = os.path.join(out_dir, f"{device.lower()}_regs.h")
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))
    return out_path

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: reggen.py <device.yaml> <out_dir>")
        sys.exit(1)
    out = gen_header(sys.argv[1], sys.argv[2])
    print(out)
